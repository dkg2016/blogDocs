# 首屏渲染
**页面首屏渲染的优化，目的是让「首页渲染完成」尽可能提前**  
**但很多情况下「首页渲染完成」可能还是空白页面，因此更重要的是让用户能够更早的看到页面内容**

## 一般网页呈现过程（[MDN：浏览器的工作原理](https://developer.mozilla.org/zh-CN/docs/Web/Performance/How_browsers_work)）
1. DNS 解析，浏览器根据域名，通过 DNS 服务器拿到域名的 IP 地址
2. 浏览器根据 IP 地址向服务器发起 HTTP 请求
3. 服务器处理 HTTP 请求，并返回给浏览器
4. 浏览器得到返回内容（ HTML、JS、CSS、媒体文件...）
5. 渲染过程
   1. 根据 HTML 代码生成 DOM Tree（同时遇到开始异步加载其他资源，如CSS、JS、字体...）
   2. 根据 CSS 生成 [CSSOM](https://developer.mozilla.org/zh-CN/docs/Glossary/CSSOM)
   3. **渲染树**：将 DOM Tree 和 CSSOM 整合形成 Render Tree（渲染树只包含了可见内容）
   4. **布局**：根据 Render Tree 渲染页面（在哪里和如何在页面上放置元素，决定了每个元素的宽和高，以及他们之间的相关性)（回流）
   5. **绘制**：将布局绘制在屏幕上（重绘）
   6. 遇到 script（特别是没有 async 或者 defer 属性的） 则暂停渲染，优先加载并执行 JS 代码，完成后再继续

## [小程序启动流程](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips/start_process.html)
1. 资源准备
   1. 相关信息准备，如头像、版本、配置等
   2. 运行环境准备，如小程序进程、客户端原生部分的系统组件和 UI 元素（如 导航栏、tabBar 等）、渲染页面使用的 WebView 容器、开发者 JavaScript 代码的运行环境、小程序基础库
   3. 代码包准备，类似一般页面加载的 JS文件大小
2. 逻辑层-代码注入
3. 视图层-代码注入
   1. **视图层和逻辑层的小程序代码注入是并行进行的。**
4. 首页(初次)渲染
   1. 在逻辑层小程序代码注入完成后，小程序框架会根据用户访问的页面，进行页面组件树初始化，生成初始数据发送到视图层，并依次触发首页的 Page.onLoad, Page.onShow 生命周期
5. 首屏内容展示
   1. 异步 触发 setData

普通网页的加载流程，可以对应到小程序代码包准备这一步，就是开始加载文件。有一点需要注意，**小程序视图层和逻辑层的代码注入是并行进行的。而在普通网页中，如果不是异步 script，是会阻塞视图层的渲染的。**

## 优化方向
### 一. 资源加载更快
   1. **更小的代码体积**
      #### 场景一：慎重使用第三方 UI 框架、工具包
      ***
      通用框架，尤其UI框架，因为功能丰富，组件引用，不可避免的存在体积过大的问题  
      和自己开发的相比，体积大很多，非必要，非必须，不引入第三方包  
      小程序移除 Vant 对 JS注入耗时对影响
      ![An Image](/assets/remove-vant.png)
   3. **更好的网络**
   4. **资源缓存**
      #### 场景1: 浏览器 Storage
      ***
      首页需要获取和用户绑定的一本书籍 bindBookId，再根据 bindBookId 获取书的详情  
      用户的 bindBookId 只能由用户手动更新  

      不需要每次进来都获取一次用户的 bindBookId。在用户第一次设置 bindBookId 时，就缓存下来。之后每次都取缓存中的值   
      **只需要在用户次设置 bindBookId 时，更新缓存中的 bindBookId**

      相比发起一个请求，使用缓存的消耗的时间少很多，**空间换时间**

      #### 场景2： 网络缓存
      ***
      （暂未使用到，仅记录知识）
      1. 强缓存
         1. Expires，此时间后过期（资源失效日期）
         2. Cache-Control（优先级高）
      2. 协商缓存
         1. Last-Modified 和 If-Modified-Since
         2. ETag 和 If-None-Match
      3. 选择合适的缓存策略
         1. 对于某些不需要缓存的资源，可以使用 Cache-control: no-store ，表示该资源不需要缓存
         2. 对于频繁变动的资源，可以使用 Cache-Control: no-cache 并配合 ETag 使用，表示该资源已被缓存，但是每次都会发送请求询问资源是否更新
         3. 对于代码文件来说，通常使用 Cache-Control: max-age=31536000 并配合策略缓存使用，然后对文件进行指纹处理，一旦文件名变动就会立刻下载新的文件
### 二. 页面渲染更快
   1. **更早的执行 JS**
      #### 场景1：合理异步
      伪代码逻辑
      ``` js
        async isLogin ? async getLocation -> async ajax login data -> render
                      : async getLocation -> async ajax unLogin data -> render
      ```

      **isLogin 和 getLocation 两个异步行为是线性关系，在 getLocation 完成后，才开始 Ajax 请求数据。但实际上并没有相互依赖关系。导致的后果就是，如果两个异步行为的时间分别为 300ms 和 100ms，那么 Ajax 至少要在 400ms 之后才开启**

      **既然没有相互依赖关系，完全可以将 isLogin 和 getLocation 同时开始，Ajax 将在 isLogin 和 getLocation 中耗时比较长的的那个结束后，马上发起。既提前了 Ajax 开启的时间，又保证了 login 和 location 状态都已经获取到**

      ::: tip 
      可以使用 Peomise.all() 或者 发布订阅 模式实现 
      :::

      #### 修改前
      > 8 次记录值（Redmi K30， wifi，单位 ms )

      |         | onLoad | isLogin | location | Ajax Start | Ajax End |
      | ------- |:-------|:--------|:---------|:-----------|:---------|
      | 1       | 232    | 275     | 415      | 439        | 578      |
      | 2       | 242    | 298     | 363      | 379        | 501      |
      | 3       | 179    | 221     | 334      | 349        | 475      |
      | 4       | 177    | 234     | 318      | 333        | 521      |
      | 5       | 213    | 323     | 365      | 380        | 504      |
      | 6       | 237    | 280     | 370      | 387        | 528      |
      | 7       | 212    | 257     | 323      | 338        | 456      |
      | 8       | 205    | 314     | 376      | 425        | 523      |
      | Average |        |         |          | **:angry:378.75**     | 510.75      | 

      #### 修改后

      |         | onLoad | isLogin | location | Ajax Start | Ajax End |
      | ------- |:-------|:--------|:---------|:-----------|:---------|
      | 1       | 194    | 250     | 250      | 253        | 367      |
      | 2       | 196    | 252     | 251      | 255        | 382      |
      | 3       | 219    | 278     | 278      | 281        | 417      |
      | 4       | 183    | 234     | 234      | 236        | 361      |
      | 5       | 212    | 283     | 282      | 285        | 403      |
      | 6       | 242    | 301     | 301      | 304        | 401      |
      | 7       | 215    | 279     | 279      | 283        | 413      |
      | 8       | 168    | 238     | 238      | 245        | 338      |
      | Average |        |         |          | **:star_struck:267.75**     | 385.25   |

      Ajax 开始的时间，提前大约 110ms
   2. **预加载**
   3. **预渲染**
   4. **懒加载**
      #### 场景一：小程序的 按需注入 和 用时注入
      按需注入 是针对整个程序的懒加载  
      用时注入 是针对页面的懒加载
      ***
      >通常情况下，在小程序启动时，启动页面依赖的所有代码包（主包、分包、插件包、扩展库等）的所有 JS 代码会全部合并注入，包括其他未访问的页面以及未用到自定义组件，同时所有页面和自定义组件的 JS 代码会被立刻执行。这造成很多没有使用的代码在小程序运行环境中注入执行，影响注入耗时和内存占用。  

      启用按需注入后，小程序仅注入当前访问页面所需的自定义组件和页面代码。未访问的页面、当前页面未声明的自定义组件不会被加载和初始化，对应代码文件将不被执行

      >「用时注入」可以指定一部分自定义组件不在小程序启动时注入，而是在真正渲染的时候才进行注  

      首页会引入了很多组件，但是有些组件用到的频率很低，只在某些少有的情况下才会使用到。那么这些组件，就不需要随着首页的加载而加载，只需要在真正使用到时，再触发该组件的加载。
   5. **懒执行**
   6. **逻辑优化**
      #### 场景
      时常回头看，及时清理无用代码和资源